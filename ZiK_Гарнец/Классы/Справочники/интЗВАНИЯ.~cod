Class inherited ћашина–еквизитов.Ѕазовые.инт«апись "»нтерфейс: —правочники.«¬јЌ»я";

  Import —»—2     Classes ‘ункции, —троковые‘ункции, ‘ункцииƒокумента;
  Import ѕервичка Classes  онстанты, ‘ункции, Ѕиблио, Ќумератор;
  Import          Classes  онстанты;

InClass Public

  ---------------------------------------------------------
  func —в€занный ласс«аписей : Class —»—2.Ѕазова€.Ѕазова€«апись;
    Result = —правочники.«¬јЌ»я;
  end;

  func Create :—правочники.инт«¬јЌ»я;
    Result        = inherited Create;
    Result.Record = —правочники.«¬јЌ»я.Create;
    if Result.Record.GroupDoc = Nil then
    »наче
       Result.Record.“ип«аписи = Result.Record.GroupDoc.“ип«аписи;
    end;
  end;

  func ќткрытьѕо«аписи synonym OpenRecord( aRec :—правочники.«¬јЌ»я ) :—правочники.инт«¬јЌ»я;
    Result        = inherited Create;
    Result.Record = aRec;
    Result.Record.“ип«аписи = aRec.GroupDoc.“ип«аписи;
  end;

  -- функци€ возвращает бланк-редактор записи по умолчанию
  func Ѕланк–едакторѕо”молчанию :Class BlankForm;
    Result = —правочники.ред«¬јЌ»я;
  end;

  func Ѕланк–едакторѕо«аписи (aRecord :Record) :Class BlankForm;
    if aRecord<>nil then
      if    aRecord.“ип«аписи in [0, 1] then Result = —правочники.ред«¬јЌ»я;
      elsif aRecord.“ип«аписи = 2       then Result = —правочники.ред«¬јЌ»я;
      elsif aRecord.“ип«аписи = 3       then Result = —правочники.ред«¬јЌ»я;

      end;
    else
      Result = Ѕланк–едакторѕо”молчанию;
    end;
  end;

  -- функци€ возвращает картотеку записи по умолчанию
  func  артотекаѕо”молчанию :Class CardForm;
    Result = —правочники.карт«¬јЌ»я;
  end;

  func  артотекаѕо«аписи (aRecord :Record) :Class CardForm;
    if aRecord<>nil then
      if    aRecord.“ип«аписи in [0, 1] then Result = —правочники.карт«¬јЌ»я;
      elsif aRecord.“ип«аписи = 2       then Result = —правочники.карт«¬јЌ»я;
      elsif aRecord.“ип«аписи = 3       then Result = —правочники.карт«¬јЌ»я;

      end;
    else
      Result =  артотекаѕо”молчанию;
    end;
  end;

InClass Private

InObject Public

  Record :—правочники.«¬јЌ»я;

  proc »нициализировать synonym Init(а»м€  :String = '';
                                     а од  :String = '');
    Assert(Record.State = Kernel.Record.Created);
    with Record do
      if »м€ = '' then
        if GroupDoc.“ип«аписи=2  then
          »м€ = 'Ќовое звание/учЄна€ степень';
        ≈сли∆е GroupDoc.“ип«аписи=3  then
          »м€ = 'Ќовое ученое звание';
        »наче
          »м€ = 'Ќовое —пециальное/воинское звани€';
        end;
      end;
      if Record. од = '' then
        «аполнитьЌомерƒокумента2([" од"]);
        if а од <> '' then
           од = а од;
        end;
      end;
       од‘илиала = ѕолучить од‘илиала;
      ”ровень онфиденциальности = ѕолучить”ровень онфидѕо”молчанию;
      Modified = False;
    end;
  end;

  proc »нициализироватьѕо”молчанию synonym InitByDefault;
    Init;
  end;

InObject Private

  -- ѕеременные дл€ заполнени€ параметров нумерации по умолчанию...
  var Ќумератор_—пособы[]      :Integer   = [снƒокумент_ѕоследовательно];
  var Ќумератор_ѕол€Ќумерации[]:String    = [" од"];
  --------------------------------------------------------------------
  proc ƒействи€ѕеред«аписью;
    var локƒобавлено :Logical;

    inherited ƒействи€ѕеред«аписью;

    ѕервичка.Ѕазовые.интЅазовый¬ид–асчета.—бросить эширование;
    Record.GroupDoc = √руппаƒл€Ёлементаѕо«аписи(локƒобавлено);
    if локƒобавлено then
      «аполнитьЌомерƒокумента2([" од"]);
    end;
  end;
  ---------------------------------------------------------
  func »м€¬ерхней√руппыѕо“ипу«аписи(const а“ип–асчета :÷елое;
                                      var а“ип√руппы  :—правочники.«¬јЌ»я;
                                      var аќписание   :String):String;
 --0...1-—пец. «вание, 2-”чена€ —тепень, 3-”ченое «вание
    if а“ип–асчета <> nil then
      if    а“ип–асчета in [0, 1] then
        Result     = "—пециальное/¬оинское звани€";
        аќписание  = "√руппа ¬оинские звани€";
        а“ип√руппы = Record.GroupDoc;

      elsif а“ип–асчета = 2       then
        Result     = "”чена€ степень";
        аќписание  = "√руппа ”чена€ —тепень";
        а“ип√руппы = Record.GroupDoc;

      else
        Result     = "”ченое звание";
        аќписание  = "√руппа ”ченое «вание";
        а“ип√руппы = Record.GroupDoc;
      end;
    end;
  end;
  ---------------------------------------------------------
  func √руппаƒл€Ёлементаѕо«аписи(var аƒобавлено :Logical):—правочники.«¬јЌ»я;
    var vFilter      :String;
    var лок»м€√руппы :String;
    var локќписание  :String;
    var лок“ип√руппы :—правочники.«¬јЌ»я;
    var локќбщ√руппа :—правочники.«¬јЌ»я;
    var лок√руппа    :—правочники.«¬јЌ»я;

    func ѕоиск«аписиѕо‘ильтру(aFilter :String):—правочники.«¬јЌ»я;
      if aFilter<>"" then
        with Query.Create([—правочники.«¬јЌ»я]) do
          Filter = —ложить—троки‘ильтраѕо»(["isGroup<>0", aFilter]);
          Select;
          if not EOF then
            Result = Current as —правочники.«¬јЌ»я;
          end;
        end;
      end;
    end;

    Result         = Record.GroupDoc;
    лок»м€√руппы   = »м€¬ерхней√руппыѕо“ипу«аписи(Result.“ип«аписи , лок“ип√руппы, локќписание);
    if лок»м€√руппы <> "" then
      -- ѕоиск группы по типу алгоритма расчета ...
      vFilter      = —ложить—троки‘ильтраѕо»(["GroupDoc = nil and isGroup<>0",
                                              "“ип«аписи = " + Str(Result.“ип«аписи),
                                              "»м€ = '"       + лок»м€√руппы + "'"]);
      локќбщ√руппа = ѕоиск«аписиѕо‘ильтру(vFilter);

      if локќбщ√руппа <> Record then
        if локќбщ√руппа = nil then
          -- ‘ормирование группы по предпри€тию ...
          локќбщ√руппа               = —правочники.«¬јЌ»я.Create;
          локќбщ√руппа.isGroup       = True;
          локќбщ√руппа.GroupDoc      = nil;
          локќбщ√руппа.«амок         = True;
          локќбщ√руппа.“ип«аписи     = Record.“ип«аписи;
          локќбщ√руппа.»м€           = лок»м€√руппы;
          локќбщ√руппа.ќписание      = локќписание;
          with —правочники.инт«¬јЌ»я.OpenRecord(локќбщ√руппа) do
            «аполнитьЌомерƒокумента(пнќбновление,, True, [" од"]);
          end;
          RecordPost(локќбщ√руппа);
          аƒобавлено = True;
        else
          if локќбщ√руппа.«амок = False then
            RecordEdit(локќбщ√руппа);
            локќбщ√руппа.«амок = True;
          end;
          RecordPostIfNeed(локќбщ√руппа);
        end;

        -- ѕоиск вложенной группы ...
        if локќбщ√руппа <> nil then
          if Record.GroupDoc = nil then
            Result    = локќбщ√руппа;
          else
            лок√руппа = Record.GroupDoc;

            if лок√руппа <> локќбщ√руппа then
              while лок√руппа.GroupDoc <> nil do
                лок√руппа = лок√руппа.GroupDoc;
              end;
              if лок√руппа <> локќбщ√руппа then
                Result = локќбщ√руппа;
              end;
            end;
          end;
        end;
      end;
    end;
  end;

  ---------------------------------------------------------



End
