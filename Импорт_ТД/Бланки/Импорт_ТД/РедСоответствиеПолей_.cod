Class inherited МашинаРеквизитов.Базовые.редБазовыйДокумент 'Соответствие полей для Загрузки', editor Импорт_ТД.Импорт_ТД.запСоответствиеПолей;

Import                  Classes СписокКартотек, XLS, SQL, Files, Переменные;

Import СИС2             Classes Функции,функцииртти;   --ТУТ СТАНДАРТНЫЕ СПОСОБЫ ПОЛУЧЕНИЯ сЕКЦИЙ, сТРОКсЕКЦИЙ, сТОЛБЦОВсЕКЦИЙ...
import МашинаРеквизитов classes Библио;
--import сис2 classes исключения,строковыефункции,функцииртти,функциидокумента,функции;
--Import Classes Импорт_ТД.Макеты.ТаблицаСоотв ;
Import ТаблДокумент     Classes Макет, Области, Область, Параметры;

InClass  Public

  Перем ВнешнийВызов : Logical;

InObject Private

Перем Справочн  : Целое;
Перем CheckBox2 : CheckBox;
Перем CheckBox24: CheckBox;
Перем CheckBox25: CheckBox;

столбПодтаблица              : TemplateColumn;
столбОбщаяГруппа             : TemplateColumn;
столбМногостраничный         : TemplateColumn;

Заголовок                    : TemplateSection;
СекДокум                     : TemplateSection;
секПозиции                   : TemplateSection;
секцИсточник                 : TemplateSection;

СекДокум1                    : TemplateSection;  --Здесь хранится Документ для загрузки данных в "Подтаблицу"

Строки []                    : String;
Строчка[]                    : String;

НазванияКолонокПолейЗаписи []: String;
ИменаПолейЗаписи           []: String;
ТипыПолейЗаписи            []: Integer;
КлассыЗаписейДляСсылок     []: Class;
СтрокиАльтер               []: Строка;
Заполнен                     : Logical;

Интерфейс                    : Импорт_ТД.Импорт_ТД.интСоответствиеПолей;

-- Рисуем таблицу
секПриемник           : TemplateSection;    -- После этой секции рисуем таблицы. Нам нужно знать на каком фрейме и после какой секции рисовать "новые"!

Нпп                   : Integer   [];
Загружаемое           : Логическое[];
ПолеПоиска            : Логическое[];
РежимЗагрузки         : Integer   [];
ЗначениеПоУмолчанию   : Вариант   [];
НаимЗначение          : Вариант   [];
ИскатьПо              : String    [];
КартотечноеПоле       : String    [];
ТипДанныхКартПоля     : Integer   [];
ТипДанныхЗначение     : String    [];
ЗагружаемоеПоле       : Integer   [];
ИмяЗагружПоля         : String    [];
ТипДанныхЗагрПоля     : Integer   [];
ColumnsXLS            : String    [];
РасчетноеВыражение    : String    [];

ИтогоПоЛисту          : Число       ;
Всего                 : Число       ;
-- Рисуем таблицу

СлужебныеПоля :String[] = [
                           'DocID'                     ,
                           'ExtID'                     ,
                           'ModifyDate'                ,
                           'CreateDate'                ,
                           'CreateUser'                ,
                           'UpdateDate'                ,
                           'UpdateUser'                ,
                           'CreateCode'                ,
                           'Version'                   ,
                           'UpdateUser'                ,
                           'КодФилиала'                ,
                           'УровеньКонфиденциальности' ,
                           'ЭлементСБ'                 ,
                           'КодПодсистемы'             ,
                           'КодМодуля'                 ,
                           'КодУчастника'              ,
                           'Замок'                     ,
                           'ТипПроцесса'               ,
                           'НеОтображаетсяВДереве'     ,
                           'WebUser'                   ,
                           'WebForm'                   ,
                           'Завершен'                  ,
                           'GroupPath'
                           ];

----------------------------------------------------------------------------------
var КоличЗагружПолей : Integer;
var FData            : Вариант[2];

  func ПолессылкаДокументПриВходе(Cell :TemplateCell; Index :Integer; Action :Template.EnterTypes) :Logical;
    var Klass : Класс ;
    var C     : Класс Ядро.ФормаКартотеки;
    var DD    : Запись;
    -- Параметры:
    --   Cell: клетка шаблона
    --   Index: номер кадра, в котором находится клетка
    --   Action: тип входа (Вход,Вставка,Очистка)
        --Klass = МашинаРеквизитов.Библио.ПолучитьКартотекуПоУмолчаниюДляКлассаЗаписи(DD);
        --СИС2.ФункцииКонсоли.НайтиФормуКартотеки( Стр(ФормаКарт) );
        -- ФормаКарт.ShowForm()  ;

        --if (ОткрытьКартотеку(  Стр(ФормаКарт) ,DD, "" ) = cmOK)  then      --Проверка    ФормаКарт.ShowForm

         --  ссылкаДокумент = DD;

        --end;
     
    Result = True; -- Разрешаем войти в поле
  end;

  func ПолеПодтаблицаДанныхПриВходе(Cell :TemplateCell; Index :Integer; Action :Template.EnterTypes) :Logical;
    -- Параметры:
    --   Cell: клетка шаблона
    --   Index: номер кадра, в котором находится клетка
    --   Action: тип входа (Вход,Вставка,Очистка)
     
    Result = True; -- Разрешаем войти в поле
  end;

  func ПолеИмяЛистаПриВводе(Cell :TemplateCell; Value :Variant) :Logical;
    -- Введенное значение корректно. Присвоить его переменной поля
    -- Параметры:
    --   Cell: клетка шаблона
    --   Value: введенное в поле значение
    если ИмяЛиста=Value тогда
       ЧтениеДанных  ;
    конец;

    Result = True; -- Продолжаем стандартную обработку
  end;

  func ПолеПодтаблицаДанныхПриВводе(Cell :TemplateCell; Value :Variant) :Logical;
    -- Введенное значение корректно. Присвоить его переменной поля
    -- Параметры:
    --   Cell: клетка шаблона
    --   Value: введенное в поле значение 
     
    Result = True; -- Продолжаем стандартную обработку
  end;


  proc ПолеИскатьПоПриРисовании            (Cell :TemplateCell; Selected :Logical; var Color :Integer; var FieldColor :Integer;
 Font :Font);
    IF  Match(Cell.Содержимое, "ИскатьПо*")   then
         --ПолеРасчетноеВыражениеПриПроверке  (Клетка, Индекс , Действие); -- Клетка.Contents
    end;
  end;

  func ПолеИскатьПоПриВходе                (Cell :TemplateCell; Index    :Integer; Action    :Template.EnterTypes) :Logical;
    IF  Match(Cell.Содержимое, "ИскатьПо*")   then
         --ПолеРасчетноеВыражениеПриПроверке  (Клетка, Индекс , Действие); -- Клетка.Contents

    end;
    Result = True; -- Разрешаем войти в поле
  end;

  func ПолеИскатьПоПриОбзоре               (Cell :TemplateCell; Value :Variant; var NewValue :Variant) :Logical;
         IF Cell.Содержимое = "ИскатьПо" then  --Этот бланк, а не внешний
         Иначе


         end;
    Result = True; -- Продолжаем стандартную обработку
  end;
----------------------------------------------------------------------------------
  функ ПриВходе                            (Клетка      : КлеткаШаблона; Индекс :Целое; Действие :Шаблон.ТипыВхода) :Логическое;

    IF     Match(Клетка.Содержимое, "ТипСправочника")        then
         ПолеПриВходе                    (Клетка, Индекс , Действие);
    ELSIF  Match(Клетка.Содержимое, "ИмяОбъекта")            then
         ПолеПриВходе                    (Клетка, Индекс , Действие);
    ELSIF  Match(Клетка.Содержимое, "ИскатьПо*")             then
         IF Клетка.Содержимое = "ИскатьПо" then  --Этот бланк, а не внешний
         Иначе
            ПолеИскатьПоПриВходе         (Клетка, Индекс , Действие);
         end;
    ELSIF  Match(Клетка.Содержимое, "РежимЗагрузки*")        then

    ELSIF  Match(Клетка.Содержимое, "ЗначениеПоУмолчанию*")  then
         ПолеЗначениеПоУмолчаниюПриВходе (Клетка, Индекс , Действие);
    ELSIF  Match(Клетка.Содержимое, "РасчетноеВыражение*")   then
         ПолеРасчетноеВыражениеПриВходе  (Клетка, Индекс , Действие); -- Клетка.Contents
    end;

    Result = Истина; -- Разрешаем войти в поле
  конец;
----------------------------------------------------------------------------------
  func ПриПроверке                         (Cell        : TemplateCell; Index :Integer; var Value :Variant) :Logical;
    IF  Match(Cell.Содержимое, "ИскатьПо*")   then
         --ПолеРасчетноеВыражениеПриПроверке  (Клетка, Индекс , Действие); -- Клетка.Contents
    end;
    Result = True; -- Разрешаем сохранить изменения в поле
  end;

  proc ПриРисовании                        (Cell        : TemplateCell; Selected :Logical; var Color :Integer; var FieldColor :Integer; Font :Font);
    IF  Match(Cell.Содержимое, "ИскатьПо*")   then
         ПолеИскатьПоПриРисовании (Cell , Selected , Color , FieldColor , Font); -- Клетка.Contents
    end;
  end;

  func ПриОбзоре                           (Cell        : TemplateCell; Value :Variant; var NewValue :Variant) :Logical;
    var TempSec  : TemplateSection;
    IF      Match(Cell.Содержимое, "ИскатьПо*")   then
         --ПолеРасчетноеВыражениеПриПроверке  (Клетка, Индекс , Действие); -- Клетка.Contents
    ЕслиЖе  Match(Cell.Содержимое, "РежимЗагрузки*")   then
            TempSec = Cell.Owner;
            TempSec.Cell[4,1].List.Clear;
            -- DeleteSection (ИмяЛистов);
            TempSec.Cell[4,1].List.Add("Поиск");
            TempSec.Cell[4,1].List.Add("Расчёт");
            TempSec.Cell[4,1].List.Add("Устанавливать");

    end;
    Result = True; -- Продолжаем стандартную обработку
  end;

  функ ПриНажатии                          (Cell        : КлеткаШаблона; Действие :Шаблон.ТипыНажатия) :Логическое;
    IF  Match(Cell.Содержимое, "ИскатьПо*")   then
         --ПолеРасчетноеВыражениеПриПроверке  (Клетка, Индекс , Действие); -- Клетка.Contents
    end;
    Result = Истина; -- Разрешаем стандартную обработку
  конец;

  func Cells_OnOutput                      (Cell        : TemplateCell; Value :Variant; Action :Template.OutputTypes; var Format :String) :Variant;
      if Action = Template.Output then
        Result  = Evaluate(Cell.Contents);
      end;
      if Value=NIL then
      Иначе
        if Action = Template.Calculation then
          Result  = Evaluate(Cell.Contents);
        end;
      end;
  end;
----------------------------------------------------------------------------------
  функ ПолеПриВходе                        (Клетка      : КлеткаШаблона; Индекс :Целое; Действие :Шаблон.ТипыВхода) :Логическое;
    var Klass : Класс ;
    var C     : Класс Ядро.ФормаКартотеки;
    var DD    : Класс Запись;
    var DDD   :       Запись;
      IF Клетка.Содержимое = "ТипСправочника" then
        if ChooseClass ( Sign, C, "Выберите класс связанной записи...") = cmOK then
           ТипСправочника = Стр( C ) ;
        end;
        ОбъектСправочника = "";
        ИмяОбъекта        = "";
        Result            = Ложь;
        ВОЗВРАТ;
      end;
      IF Клетка.Содержимое = "ИмяОбъекта" И ТипСправочника > "" then
        DD    = СИС2.ФункцииРТТИ.ПолучитьКлассЗаписиПоКлассуСправочника(НайтиКласс(ТипСправочника));
        --Проверка
        IF  DD = NIL then
          ОбъектСправочника = "";
          Сообщение("Неудалось Получить Класс Записи По Классу Справочника '"+ ТипСправочника +"'!");
         ВОЗВРАТ;
        end;
        --Проверка
        Klass = МашинаРеквизитов.Библио.ПолучитьКартотекуПоУмолчаниюДляКлассаЗаписи(DD);   -- МашинаРеквизитов.Переменные.ТаблицаИнтерфейсов[2,1] ;
        --Проверка
        IF  Klass = NIL then
          ОбъектСправочника = "";
          Сообщение("Неудалось Получить Картотеку По Умолчанию Для Класса Записи - '"+ Стр(DD) +"'!");
         ВОЗВРАТ;
        end;
        --Проверка
        if Klass.ShowFormEx(DDD, "", Window.ModalWindow) = cmOk then
           ОбъектСправочника = DDD.КлючЗаписиСтрока;
           ИмяОбъекта        = DDD.Имя             ;
        end;
        Result = Ложь;
      end;
  конец;
----------------------------------------------------------------------------------
  proc шаблон_ПриОткрытии                  (Create      : Logical);
    var Стр, I   : Целое;
    var хПодтаблица  : Подтаблица;
    inherited шаблон_ПриОткрытии(Create);

     Если Позиции.Количество = 0 Тогда
--       замок = ложь;
         Заполнен = ложь;
         КоличЗагружПолей = 0;
     Иначе
--       замок = True;
        Заполнен = True;

       КоличЗагружПолей = 0;
       хПодтаблица      = Позиции.CreateSubtableView('Загружаемое=Истина');
       КоличЗагружПолей = хПодтаблица.count;
     Илсе;

     --ПодТаблицы Картотек
     ВидимостьПоляПодтаблица ;
     --ПодТаблицы Картотек

     --Листы Экселя
     Если ИмяЛистов.Количество = 0 Тогда
      --???
      CheckBox24.State   = Ложь;
      CheckBox24.Visible = Ложь;
      ВидимостьСтолбцаИмяЛиста;
     Иначе
      секцИсточник.Cell[4,2].List.Clear;
      секцИсточник.Cell[4,2].List.Add(" ");
      для I = 1.. ИмяЛистов.Количество цикл
        секцИсточник.Cell[4,2].List.Add( ИмяЛистов[I].GetField("Имя") );
      конец;
      CheckBox24.State = Истина;
      ВидимостьСтолбцаИмяЛиста;
     Илсе;
     --Листы Экселя

     ТестоваяЗагрузка    = Ложь; -- Данные будут записываться в Базу Данных!

     ЗаполнитьМассивыПриОткрытии ;

     --Открытие бланка из "Мониторинга Импорта"
     Если ВнешнийВызов Тогда

        ЧтениеДанных  ;

        Загрузить;

        ----------------
        Close(cmCancel); -- Закрытие Тек. Бланка!!
        ----------------
     Илсе;
     --Открытие бланка из "Мониторинга Импорта"
  end;
----------------------------------------------------------------------------------
  func BlankOnVerify                                                              :Logical;
    Result = inherited шаблон_ПриПроверке;
    if код="" then
       Message("Нет кода!");
       Template.Field = "код";
       возврат ложь;
    end;
    if имя="" then
       Message("Нет названия!");
       Template.Field = "имя";
       возврат ложь;
    end;
    Result = True; -- Продолжить сохранение записи
  end;
----------------------------------------------------------------------------------
  func ПолеРасчетноеВыражениеПриПодсказке  (Cell        : TemplateCell; var Text :String) :Logical;
    Result = True; -- Разрешаем вывести подсказку
  end;
----------------------------------------------------------------------------------
  func ОчисткаПеременных                   (Стр         : Целое ) : Логическое;
    секПриемник.DeleteFrame(Стр);
    УдалитьИзМассива(Нпп                ,Стр);
    УдалитьИзМассива(Загружаемое        ,Стр);
    УдалитьИзМассива(ПолеПоиска         ,Стр);
    УдалитьИзМассива(РежимЗагрузки      ,Стр);
    УдалитьИзМассива(ЗначениеПоУмолчанию,Стр);
    УдалитьИзМассива(НаимЗначение       ,Стр);
    УдалитьИзМассива(ИскатьПо           ,Стр);
    УдалитьИзМассива(КартотечноеПоле    ,Стр);
    УдалитьИзМассива(ТипДанныхКартПоля  ,Стр);
    УдалитьИзМассива(ТипДанныхЗначение  ,Стр);
    УдалитьИзМассива(ЗагружаемоеПоле    ,Стр);
    УдалитьИзМассива(ИмяЗагружПоля      ,Стр);
    УдалитьИзМассива(ТипДанныхЗагрПоля  ,Стр);
    УдалитьИзМассива(ColumnsXLS         ,Стр);
    УдалитьИзМассива(РасчетноеВыражение ,Стр);
  end;
----------------------------------------------------------------------------------
  func DeleteСекция                                                               : Логическое;
    Перем Стр : Целое ;
       if  секПриемник.Количество=0 then
       Иначе
          для Стр = 1..секПриемник.Количество цикл
             ОчисткаПеременных(Стр);
          конец;
       конец;
  конец;
----------------------------------------------------------------------------------
  функ Ячейка_ПриНажатии                   (Клетка      : КлеткаШаблона; Действие :Шаблон.ТипыНажатия):Логическое;
    Перем Стр : Целое ;
      Стр = Клетка.Row;
      if Клетка.Contents = '+' then
          Позиции.Вставить(Стр + 1);
      ЕслиЖе Клетка.Contents = '-' then
          Позиции.Delete(Стр);
      Иначе

      конец;
    Result = Истина; -- Разрешаем стандартную обработку
  конец;
----------------------------------------------------------------------------------
  функ Ячейка_ПриНажатии_                  (Клетка      : КлеткаШаблона; Действие :Шаблон.ТипыНажатия):Логическое;
    Перем Стр : Целое ;
      Стр = If(секПриемник.Количество=0, 0,Клетка.Frame);  -- Клетка.Frame
      if     Клетка.Contents='+' then
        секПриемник.InsertFrame(Стр+1);
      ЕслиЖе Клетка.Contents='-' then
        if  секПриемник.Количество=0 then
        Иначе
            ОчисткаПеременных(Стр);
        конец;
      Иначе

      конец;
    Result=Истина; -- Разрешаем стандартную обработку
  конец;
----------------------------------------------------------------------------------
  проц ПриВыходе                           (Клетка      : КлеткаШаблона; Индекс :Целое);
   Перем Стр : Строка ;
    if    Клетка.Contents = 'ЗагружаемоеПоле' then
       if Клетка.Value = NIL then
         Позиции[Индекс].УстановитьПоле("ColumnsXLS", "");
       Иначе
         Стр = НомерКолонкиВXLSформате(Клетка.Value);
         Позиции[Индекс].УстановитьПоле("ColumnsXLS", Стр);
       конец;
    Иначе
      if Клетка.Contents = 'ColumnsXLS' then
        if Клетка.Value = NIL then
          Позиции[Индекс].УстановитьПоле("ЗагружаемоеПоле", 0                          );
        Иначе
          Позиции[Индекс].УстановитьПоле("ЗагружаемоеПоле", CharFromExcel(Клетка.Value));
        конец;
      конец;
    конец;
  конец;
-----------------------------------------------------------
  проц ВидимостьПоляПодтаблица ;

    if СекДокум1.Cell[4,1].List.Count>0 или ПодтаблицаДанных>"" then
      столбПодтаблица.Visible = Истина;
      СекДокум1.Visible       = Истина;
    ELSE
      столбПодтаблица.Visible = Ложь;
      СекДокум1.Visible       = Ложь;
    end;

конец;
-----------------------------------------------------------
  проц ВидимостьСтолбцаИмяЛиста ;
     if CheckBox24.State then
        столбМногостраничный.Visible = Истина;
     ELSE
        столбМногостраничный.Visible = Ложь;
     end;
  конец;
-----------------------------------------------------------


  проц ЗаполнитьМассивыПриОткрытии ;
   Перем Индекс,Z : integer;
     Z  = Позиции.Количество ;
     if Z = 0 then
     ELSE
       for Индекс = 1 .. Z do
          ВставитьВМассив(Нпп                 ,Индекс,Позиции[Индекс].GetField("Нпп")                    );
          ВставитьВМассив(Загружаемое         ,Индекс,Позиции[Индекс].GetField("Загружаемое")            );
          ВставитьВМассив(ПолеПоиска          ,Индекс,Позиции[Индекс].GetField("ПолеПоиска")             );
          ВставитьВМассив(РежимЗагрузки       ,Индекс,Позиции[Индекс].GetField("РежимЗагрузки")          );
          ВставитьВМассив(ЗначениеПоУмолчанию ,Индекс,Позиции[Индекс].GetField("ЗначениеПоУмолчанию")    );
          ВставитьВМассив(НаимЗначение        ,Индекс,Позиции[Индекс].GetField("НаимЗначение")           );
          ВставитьВМассив(ИскатьПо            ,Индекс,Позиции[Индекс].GetField("ИскатьПо")               );
          ВставитьВМассив(КартотечноеПоле     ,Индекс,Позиции[Индекс].GetField("КартотечноеПоле")        );
          ВставитьВМассив(ТипДанныхКартПоля   ,Индекс,Позиции[Индекс].GetField("ТипДанныхКартПоля")      );
          ВставитьВМассив(ТипДанныхЗначение   ,Индекс,Позиции[Индекс].GetField("ТипДанныхЗначение")      );
          ВставитьВМассив(ЗагружаемоеПоле     ,Индекс,Позиции[Индекс].GetField("ЗагружаемоеПоле")        );
          ВставитьВМассив(ИмяЗагружПоля       ,Индекс,Позиции[Индекс].GetField("ИмяЗагружПоля")          );
          ВставитьВМассив(ТипДанныхЗагрПоля   ,Индекс,Позиции[Индекс].GetField("ТипДанныхЗагрПоля")      );
          ВставитьВМассив(ColumnsXLS          ,Индекс,Позиции[Индекс].GetField("ColumnsXLS")             );
          ВставитьВМассив(РасчетноеВыражение  ,Индекс,Позиции[Индекс].GetField("РасчетноеВыражение")     );
       Od;
     end;
  конец;
-----------------------------------------------------------
  проц Секция_ПослеВставки                 (Секция      : СекцияШаблона; Индекс :Целое);
  -- Действия после вставки кадра в периодическую секцию
     Позиции[Индекс].УстановитьПоле ("Нпп",             Индекс           );
     --Позиции[Индекс].УстановитьПоле ("ЗагружаемоеПоле", Индекс           );
--     Позиции[Индекс].УстановитьПоле ("ColumnsXLS",      ExcelChar(Индекс));
--     Позиции[Индекс].УстановитьПоле ("ЗагружаемоеПоле", CharFromExcel(Позиции[Индекс].GetField("ColumnsXLS")) );
     --Позиции[Индекс].УстановитьПоле ("ColumnsXLS",      ExcelChar(Индекс));
--     Нпп             [Индекс]     =     Индекс           ;
--     ЗагружаемоеПоле [Индекс]     =     Индекс           ;
--     ColumnsXLS      [Индекс]     =     ExcelChar(Индекс);
  конец;
---------------------------------------------------------
  proc ВсеПоляЗаписиЗаполнить              (Name        : String; ResType: String; JJ: integer);
   Перем J : integer;
     if СистемныеПоля then
       Позиции.Вставить(Позиции.Количество + 1);
       ----------
       --секПриемник.InsertFrame(секПриемник.Количество+1);
       ----------
       J = Позиции.Количество ;
       --Заполнение других полей
       Секция_ПослеВставки( Nil, J);
       --Заполнение других полей
       Позиции[J].УстановитьПоле ("КартотечноеПоле",   Name   );
       Позиции[J].УстановитьПоле ("ТипДанныхЗначение", ResType);
       Позиции[J].УстановитьПоле ("ТипДанныхКартПоля", JJ     );

       КартотечноеПоле     [J] = Name   ;
       ТипДанныхЗначение   [J] = ResType;
       ТипДанныхКартПоля   [J] = JJ     ;

       ИзменяемТипПоля_ЗначениеПоУмолчанию_ (J);
     else
       if SearchInArray (СлужебныеПоля, Name)=-1 then  --Нет Служебного Поля
         Позиции.Вставить(Позиции.Количество + 1);
         J = Позиции.Количество ;
         --Заполнение других полей
         Секция_ПослеВставки( Nil, J);
         --Заполнение других полей
         Позиции[J].УстановитьПоле ("КартотечноеПоле",   Name   );
         Позиции[J].УстановитьПоле ("ТипДанныхЗначение", ResType);
         Позиции[J].УстановитьПоле ("ТипДанныхКартПоля", JJ     );

         КартотечноеПоле     [J] = Name   ;
         ТипДанныхЗначение   [J] = ResType;
         ТипДанныхКартПоля   [J] = JJ     ;

         ИзменяемТипПоля_ЗначениеПоУмолчанию_ (J);
       end;
     end;
end;
---------------------------------------------------------
  функ ПолеПриНажатии                      (Клетка      : КлеткаШаблона; Действие :Шаблон.ТипыНажатия) :Логическое;
    var C : Класс Ядро.ФормаКартотеки;

      if ВыборКартотеки(C) = кмдВерно then
        C.СоздатьВидимым;
      end;

    Result = Истина; -- Разрешаем стандартную обработку

  конец;
---------------------------------------------------------
  proc ПолеТипДокумПриВыходе               (Cell        : TemplateCell; Index :Integer);

    if Cell.Text="Справочники" then
       ---Self.ЧислоОбъектов ("столбПодтаблица")
    else

    end;

  end;
---------------------------------------------------------
  func ВКлассеЕстьПодтаблица               (const аКласс: class Запись) :Logical;
    var локИнфЧлена : ClassInfo;
    var I,N,Z       : Целое;
    var vMember     :FieldInfo;
    var vResType    :TypeInfo;
       Assert(аКласс <> nil);
       локИнфЧлена = аКласс.ClassInfo;
       Result      = Ложь;
       N           = Ядро.Запись.ClassInfo.MembersCount+1;
       Z           = локИнфЧлена.MembersCount;
       if N>Z then N = 1; end;
       for I = N .. локИнфЧлена.MembersCount do
         if локИнфЧлена.Member[i] is FieldInfo then  --Проверка на ПОЛЕ!!!
           vMember =локИнфЧлена.Member[i] as MethodInfo;
           vResType=vMember.ResultType;
           if (локИнфЧлена.Member[i]<>nil)and(vResType is SubtableClassInfo) then
             Result = True;
             BREAK;
           end;
         end;
       end;
  end;
---------------------------------------------------------
  функ DeleteSection                       (Позиции     : Subtable) :Логическое;
    if Позиции = Nil then
    else
      Позиции.Clear;
    end;
  end;
---------------------------------------------------------
  Проц ЗаполнитьИменаПодТаблиц             (локЗапись   : ClassInfo);
    var I       : Целое;
    var vMember : FieldInfo;
    var vResType: TypeInfo;
      for I = Ядро.Запись.ClassInfo.MembersCount+1 .. локЗапись.MembersCount do
        vMember  = локЗапись.Member[i] as FieldInfo;
        vResType = vMember.ResultType;
        if vResType is ClassInfo then
           if vResType is SubtableClassInfo then
             СекДокум1.Cell[4,1].List.Add(vMember.Name);
             ВставитьВМассив(СтрокиАльтер, СекДокум1.Cell[4,1].List.Count, vMember.Name);
           end;
        end;
      end;
  end;
---------------------------------------------------------
  Проц ЗаполнитьПолямиПодТаблицы           (vClass      : Class);
    var локЗапись: ClassInfo;
    var I        : Целое;
    var vMember  : FieldInfo;
    var vResType : TypeInfo;
      Попытка
        локЗапись = НайтиКласс( Стр(vClass) +"."+ ПодтаблицаДанных ).ClassInfo;
      Исключение
        Message("В подтаблицу: "+ПодтаблицаДанных+" загрузка не возможна!");
        ВОЗВРАТ;
      конец;
      for I = 1 .. локЗапись.MembersCount do
        Трассировка( "[  "+ Стр(I) +"]"+ Стр(vClass) +"."+ ПодтаблицаДанных + "." + локЗапись.Member[i].Name);
        if локЗапись.Member[i] is FieldInfo then
          vMember  = локЗапись.Member[i] as FieldInfo;
          vResType = vMember.ResultType;
          if vResType is ClassInfo then
            if vResType is RecordClassInfo then
               ВсеПоляЗаписиЗаполнить( vMember.Name, "{"+(vResType as RecordClassInfo).ProjectName+"."+vResType.Name+"}", 11);
            elsif vResType is StructureClassInfo then
              if СистемныеПоля then
                ВсеПоляЗаписиЗаполнить( vMember.Name, "13", 13);
              end;
            end;
          else
             ВсеПоляЗаписиЗаполнить( vMember.Name, Str(vResType.VarType) , vResType.VarType);
          end;
        end;
      end;
  end;
---------------------------------------------------------
  Проц ЗаполнитьПолямиТаблицы              (локЗапись   : ClassInfo);
    var I,F        : Целое;
    var vMember    : FieldInfo;
    var vResType   : TypeInfo;
      F     = Ядро.Запись.ClassInfo.MembersCount;
      for I = F  .. локЗапись.MembersCount do
        if I = F then
          if ВКлассеЕстьПоле(lClass, "GroupPath") then
             ВсеПоляЗаписиЗаполнить("GroupDoc", "{"+Стр(lClass)+"}" , 11 );
          end;
        Иначе
          vMember  = локЗапись.Member[i] as FieldInfo;
          vResType = vMember.ResultType;
          if vResType is ClassInfo then
             if vResType is RecordClassInfo then
                 ВсеПоляЗаписиЗаполнить(vMember.Name, "{"+(vResType as RecordClassInfo).ProjectName+"."+vResType.Name+"}" , 11 );
             elsif vResType is SubtableClassInfo then
               if СистемныеПоля then
                 ВсеПоляЗаписиЗаполнить(vMember.Name, "12", 12);
               end;
             elsif vResType is StructureClassInfo then
               if СистемныеПоля then
                 ВсеПоляЗаписиЗаполнить(vMember.Name, "13", 13);
               end;
             end;
          else
            ВсеПоляЗаписиЗаполнить(vMember.Name, Str(vResType.VarType), vResType.VarType );
          end;
        end;
      end;

  end;
---------------------------------------------------------
  var ФормаКарт   : Класс Ядро.ФормаКартотеки;
---------------------------------------------------------
  функ ПолеКартотекаИмпортаПриВходе        (Клетка      : КлеткаШаблона; Индекс:Целое; Действие:Шаблон.ТипыВхода):Логическое;
    var Номер       : Целое;
    var локЗапись   : ClassInfo;
    var локПоле     : String;
    var vClass      : Class;
    var ВПодтаблицу : Логическое;
    var ref         : Запись;

        ВПодтаблицу = Ложь;
        СтрокиАльтер= Nil;
        if ТипДокум="Справочники" then --Справочники
          DeleteSection (Позиции);
          ПодтаблицаДанных="";
          СекДокум1.Cell[4,1].List.Clear;
          локПоле= "спрРесурс";

          if ChooseReference(локПоле)=кмдВерно then
              vClass           = СИС2.ФункцииРТТИ.ПолучитьКлассЗаписиПоКлассуСправочника(НайтиКласс(локПоле));
              lClass           = vClass;
              КартотекаИмпорта = Стр(vClass);
              локЗапись        = vClass.ClassInfo;
              if ВКлассеЕстьПодтаблица(vClass) then
                if Вопрос ( , "Приемник имеет подтаблицу. Выбрать подтаблицу?", ["Да","Нет"]) = 1 then
                   ЗаполнитьИменаПодТаблиц (локЗапись);
                   ВПодтаблицу = Истина;
                end;
              end;
              if ВПодтаблицу и ПодтаблицаДанных="" then
                Номер = Альтернатива ( "Выберите Подтаблицу для загрузки...     ", СтрокиАльтер, 20) ;
                if Номер = 0 then
                else
                  ПодтаблицаДанных=СтрокиАльтер[Номер];
                fi;
              end;
              if ВПодтаблицу и ПодтаблицаДанных>"" then
                  ЗаполнитьПолямиПодТаблицы (vClass);
              else
                  ЗаполнитьПолямиТаблицы (локЗапись);
              end;
          else
             Message("Справочник не выбран!");
          end;
        else    --Документы
          if ВыборКартотеки(ФормаКарт) = кмдВерно then
            КартотекаИмпорта = Стр(ФормаКарт.Записи);
            КартотекаИмпорта = ПодСтр(КартотекаИмпорта,2,Длина(КартотекаИмпорта)-2);
            vClass           = НайтиКласс( КартотекаИмпорта );
            локЗапись        = vClass.ClassInfo;
              DeleteSection (Позиции);
              СекДокум1.Cell[4,1].List.Clear;
              ПодтаблицаДанных="";
              if ВКлассеЕстьПодтаблица(vClass) then
                 if Вопрос ( , "Приемник имеет подтаблицу. Загружать в подтаблицу?", ["Да","Нет"]) = 1 then
                    ЗаполнитьИменаПодТаблиц (локЗапись);
                    ВПодтаблицу = Истина;
                 end;
              end;
              if ВПодтаблицу и ПодтаблицаДанных="" then
                Номер = Альтернатива ( "Выберите Подтаблицу для загрузки...", СтрокиАльтер, 20);
                if Номер=0 then
                else
                  ПодтаблицаДанных=СтрокиАльтер[Номер];

                  if OpenCardFile(Стр(ФормаКарт), ref, , window.modalwindow) = cmOk then
                    if ref <> nil then
                        ссылкаДокумент = ref;
                    end;
                  end;
                fi;
              end;
              if ВПодтаблицу и ПодтаблицаДанных>"" then
                ЗаполнитьПолямиПодТаблицы (vClass);
              else
                ЗаполнитьПолямиТаблицы    (локЗапись);
              end;
          else
             Message("Документ не выбран!");
          end;
        end;
    -------
    ВидимостьПоляПодтаблица ;
    -------
    Result = Истина; -- Разрешаем войти в поле
  конец;
---------------------------------------------------------
  func ПолеЗначениеПоУмолчаниюПриНажатии   (Cell        : TemplateCell; Action : Template.ClickTypes):Logical;
    Перем Row            : Целое ;
--    Перем ТипДанКартПоля : Целое ;

        Row = Cell.Row;   -- Cell.Владелец.Имя
--        ТипДанКартПоля = Позиции[Row].GetField("ТипДанныхКартПоля");

    Result = True; -- Разрешаем стандартную обработку
  end;
  ---------------------------------------------------------
  func ПроверкаСоответствияДанныхПрошла          (Cell        : TemplateCell; Row: Integer):Logical;
    Перем Реж            : Целое ;
    Перем ТипДанКартПоля : Целое ;
    Перем DD             : Запись;
    Перем КлассДанных    : Строка;
    Перем vClass         : Class;
    Перем Cell_Value     : String;
    Перем Загр           :Logical;

    Реж        = Позиции[Row].GetField("РежимЗагрузки");
    Загр       = Позиции[Row].GetField("Загружаемое");
    Cell_Value = Cell.Value;
    Result     = True;
        ТипДанКартПоля = Позиции[Row].GetField("ТипДанныхКартПоля");
        if    ТипДанКартПоля=0  then

        ELSIF ТипДанКартПоля=1  then
        ELSIF ТипДанКартПоля=2  then
        ELSIF ТипДанКартПоля=3  then
        ELSIF ТипДанКартПоля=4  then
        ELSIF ТипДанКартПоля=5  then
--           Cell_Value = Стр(Календарь);
--           ЗначениеПоУмолчанию[Row] = Cell_Value;
--           НаимЗначение       [Row] = Cell_Value;
        ELSIF ТипДанКартПоля=6  then
        ELSIF ТипДанКартПоля=7  then
        ELSIF ТипДанКартПоля=8  then
        ELSIF ТипДанКартПоля=9  then
        ELSIF ТипДанКартПоля=10 then
        ELSIF ТипДанКартПоля=11 then
          if    Реж=0 then
          ELSIF Реж=1 then
          ELSIF Реж=2 then
             if Загр then

             ELSIF НЕ Загр then
               Сообщение('Строчка должна быть Загружаемая!');
               Result = Ложь;
             end;
          end;
        end;
  end;
  ---------------------------------------------------------

  func ПолеЗначениеПоУмолчаниюПриВходе     (Cell        : TemplateCell; Index  : Integer; Action: Template.EnterTypes) :Logical;
    Перем Row            : Целое ;
    Перем ТипДанКартПоля : Целое ;
    Перем DD             : Запись;
    Перем КЛС            : Вариант;
    Перем КлассДанных    : Строка;
    Перем vClass         : Class;
    Перем Cell_Value     : String;
    Row=Index; Cell_Value = Стр(Cell.Value);
    Result = True; -- Разрешаем войти в поле
        ТипДанКартПоля = Позиции[Row].GetField("ТипДанныхКартПоля");
        if    ТипДанКартПоля=0  then
          if ПроверкаСоответствияДанныхПрошла (Cell , Index) then
          end;
        ELSIF ТипДанКартПоля=1  then
          if ПроверкаСоответствияДанныхПрошла (Cell , Index) then
          end;
        ELSIF ТипДанКартПоля=2  then
          if ПроверкаСоответствияДанныхПрошла (Cell , Index) then
          end;
        ELSIF ТипДанКартПоля=3  then
          if ПроверкаСоответствияДанныхПрошла (Cell , Index) then
          end;
        ELSIF ТипДанКартПоля=4  then
          if ПроверкаСоответствияДанныхПрошла (Cell , Index) then
          end;
        ELSIF ТипДанКартПоля=5  then
          if ПроверкаСоответствияДанныхПрошла (Cell , Index) then
            Cell_Value = Стр(Календарь);
            Позиции[Row].SetField("ЗначениеПоУмолчанию", Cell_Value);
            Позиции[Row].SetField("НаимЗначение",        Cell_Value);
          end;
        ELSIF ТипДанКартПоля=6  then
          if ПроверкаСоответствияДанныхПрошла (Cell , Index) then
          end;
        ELSIF ТипДанКартПоля=7  then
          if ПроверкаСоответствияДанныхПрошла (Cell , Index) then
          end;
        ELSIF ТипДанКартПоля=8  then
          if ПроверкаСоответствияДанныхПрошла (Cell , Index) then
          end;
        ELSIF ТипДанКартПоля=9  then
          if ПроверкаСоответствияДанныхПрошла (Cell , Index) then
          end;
        ELSIF ТипДанКартПоля=10 then
          if ПроверкаСоответствияДанныхПрошла (Cell , Index) then
          end;
        ELSIF ТипДанКартПоля=11 then
         if Позиции[Row].GetField("РежимЗагрузки")=2 then
             if ПроверкаСоответствияДанныхПрошла (Cell , Index) then
             --
               КлассДанных = Позиции[Row].GetField("ТипДанныхЗначение");
               КлассДанных = ПодСтр(КлассДанных,2,Длина(КлассДанных)-2);
               vClass = НайтиКласс(КлассДанных);
               DD     = vClass.Create  ;
               if DD = nil then
                 Трассировка("Не возможно записать данные в : "+КлассДанных);
                 Result = Ложь;
               end;
               vClass = МашинаРеквизитов.Библио.ПолучитьКартотекуПоУмолчаниюДляКлассаЗаписи(vClass);
               if vClass.ShowFormEx(DD, "", Window.ModalWindow) = cmOk then
                  Позиции[Row].SetField("ЗначениеПоУмолчанию", DD.DocIDStr);
                  КЛС = findclass( ПодСтр(Позиции[Row].GetField ("ТипДанныхЗначение"),2,Длина(Позиции[Row].GetField ("ТипДанныхЗначение"))-2));
                  if ВКлассеЕстьПоле( КЛС, "Имя") then
                    if DD.Имя="" then
                      Позиции[Row].SetField("НаимЗначение", DD.Код);
                    ELSE
                      Позиции[Row].SetField("НаимЗначение", DD.Имя);
                    end;
                  end;
                  if ВКлассеЕстьПоле( КЛС, "Код") then  --    vClass              findclass(КартотекаИмпорта)
                    if DD.Код="" then
                      Позиции[Row].SetField("НаимЗначение", DD.Имя);
                    ELSE
                      Позиции[Row].SetField("НаимЗначение", DD.Код);
                    end;
                  end;
               end;
             end;
           end;
           Result = Ложь;
        end;
  end;
  ---------------------------------------------------------
  func ПолеЗначениеПоУмолчаниюПриВходе_    (Cell        : TemplateCell; Index  : Integer; Action: Template.EnterTypes) :Logical;
    Перем Row            : Целое ;
    Перем ТипДанКартПоля : Целое ;
    Перем DD             : Запись;
    Перем КлассДанных    : Строка;
    Перем vClass         : Class;
    Перем Cell_Value     : String;
    Row        = Index;
    Cell_Value = Cell.Value;
    Result     = True;
        ТипДанКартПоля = Позиции[Row].GetField("ТипДанныхКартПоля");
        if    ТипДанКартПоля=0  then

        ELSIF ТипДанКартПоля=1  then
--           ЗначениеПоУмолчанию[Row] = Cell_Value;
--           НаимЗначение       [Row] = Cell_Value;
        ELSIF ТипДанКартПоля=2  then
--           ЗначениеПоУмолчанию[Row] = Cell_Value;
--           НаимЗначение       [Row] = Cell_Value;
        ELSIF ТипДанКартПоля=3  then
--           ЗначениеПоУмолчанию[Row] = Cell_Value;
--           НаимЗначение       [Row] = Cell_Value;
--        ELSIF ТипДанКартПоля=4  then
--           ЗначениеПоУмолчанию[Row] = Cell_Value;
--           НаимЗначение       [Row] = Cell_Value;
--        ELSIF ТипДанКартПоля=5  then
--           Cell_Value = Стр(Календарь);
--           ЗначениеПоУмолчанию[Row] = Cell_Value;
--           НаимЗначение       [Row] = Cell_Value;
--        ELSIF ТипДанКартПоля=6  then
--           ЗначениеПоУмолчанию[Row] = Cell_Value;
--           НаимЗначение       [Row] = Cell_Value;
--        ELSIF ТипДанКартПоля=7  then
--           ЗначениеПоУмолчанию[Row] = Cell_Value;
--           НаимЗначение       [Row] = Cell_Value;
--        ELSIF ТипДанКартПоля=8  then
--           ЗначениеПоУмолчанию[Row] = Cell_Value;
--           НаимЗначение       [Row] = Cell_Value;
--        ELSIF ТипДанКартПоля=9  then
--           ЗначениеПоУмолчанию[Row] = Cell_Value;
--           НаимЗначение       [Row] = Cell_Value;
--        ELSIF ТипДанКартПоля=10 then
--           ЗначениеПоУмолчанию[Row] = Cell_Value;
--           НаимЗначение       [Row] = Cell_Value;
        ELSIF ТипДанКартПоля=11 then
         if РежимЗагрузки[Row]=2 then
             КлассДанных = Позиции[Row].GetField("ТипДанныхЗначение");
             КлассДанных = ПодСтр(КлассДанных,2,Длина(КлассДанных)-2);
             vClass = НайтиКласс(КлассДанных);
             DD     = vClass.Create  ;
             if DD = nil then
               Трассировка("Не возможно записать данные в : "+КлассДанных);
               Result = Ложь;
             end;
             vClass = МашинаРеквизитов.Библио.ПолучитьКартотекуПоУмолчаниюДляКлассаЗаписи(vClass);
               if vClass.ShowFormEx(DD, "", Window.ModalWindow) = cmOk then
                  Позиции[Row].SetField("ЗначениеПоУмолчанию", DD.DocIDStr);
                  ЗначениеПоУмолчанию[Row] = DD.DocIDStr;
                  if DD.Имя="" then
                    Позиции      [Row].SetField("НаимЗначение", DD.Код);
                    НаимЗначение[Row] = DD.Код;
                  ELSE
                    Позиции[Row].SetField("НаимЗначение", DD.Имя);
                    НаимЗначение[Row] = DD.Код;
                  end;
                  if Cell.FieldType = Kernel.Template.CommonField then
                     Cell.ReadOnly  = Ложь;
                  end;
               end;
           end;
           Result = Ложь;
        end;
  end;
  ---------------------------------------------------------
  proc ИзменяемТипПоля_ЗначениеПоУмолчанию_(Позиц       : Integer);
    Перем I :Integer;
      I = Позиции[Позиц].GetField("ТипДанныхКартПоля");
--        if    I=0  then
--
--        ELSIF I=1  then
--             секПриемник.Cell[5,Позиц].CellFormat = Template.StringFormat;
--             секПриемник.Cell[5,Позиц].Button     = Ложь;
--        ELSIF I=2  then
--             секПриемник.Cell[5,Позиц].CellFormat = Template.NumericFormat;
--             секПриемник.Cell[5,Позиц].Button     = Ложь;
--        ELSIF I=3  then
--             секПриемник.Cell[5,Позиц].CellFormat = Template.NumericFormat;
--             секПриемник.Cell[5,Позиц].Button     = Ложь;
--        ELSIF I=4  then
--             секПриемник.Cell[5,Позиц].CellFormat = Template.LogicalFormat;
--        ELSIF I=5  then
--             секПриемник.Cell[5,Позиц].CellFormat = Template.DateFormat;
--             секПриемник.Cell[5,Позиц].Button     = Истина;
--        ELSIF I=6  then
--
--        ELSIF I=7  then
--             секПриемник.Cell[5,Позиц].CellFormat = Template.CommonFormat;
--        ELSIF I=8  then
--
--        ELSIF I=9  then
--
--        ELSIF I=10 then
--
--        ELSIF I=11 then
--             секПриемник.Cell[5,Позиц].CellFormat = Template.ReferenceFormat;
--             секПриемник.Cell[5,Позиц].Button     = Истина;
--        ELSIF I=12 then
--
--        ELSIF I=13 then
--
--        end;
  end;
  ---------------------------------------------------------
  proc ИзменяемТипПоля_ЗначениеПоУмолчанию (Sec         : TemplateSection; Cell: TemplateCell; Позиц :Integer);
    Перем I :Integer;
      I = Позиции[Позиц].GetField("ТипДанныхКартПоля");
        if    I=0  then

        ELSIF I=1  then
             Sec.Cell[5,Cell.Строка].CellFormat = Template.StringFormat;
        ELSIF I=2  then
             Sec.Cell[5,Cell.Строка].CellFormat = Template.NumericFormat;
        ELSIF I=3  then
             Sec.Cell[5,Cell.Строка].CellFormat = Template.NumericFormat;
        ELSIF I=4  then
             Sec.Cell[5,Cell.Строка].CellFormat = Template.LogicalFormat;
        ELSIF I=5  then
             Sec.Cell[5,Cell.Строка].CellFormat = Template.DateFormat;
        ELSIF I=6  then

        ELSIF I=7  then
             Sec.Cell[5,Cell.Строка].CellFormat = Template.CommonFormat;
        ELSIF I=8  then

        ELSIF I=9  then

        ELSIF I=10 then

        ELSIF I=11 then
             Sec.Cell[5,Cell.Строка].CellFormat = Template.ReferenceFormat;
        ELSIF I=12 then

        ELSIF I=13 then

        end;
  end;
  ---------------------------------------------------------
  proc ПолеРежимЗагрузкиПриВыходе          (Cell        : TemplateCell; Index :Integer);
    var Итер: Integer ;
    var Имя : Строка ;
    var Sec : TemplateSection;

     if Cell.Строка>0 и Cell.Столбец>0 и Cell.Кадр>0 then
       Имя  = Cell.Владелец.Имя;
       --Sec  = ВзятьСекциюПоИмени (ШАБЛОН, Имя);
       --if Sec = Nil then
         ------------------
       --иначе
         Трассировка("Секция='"+Имя+"',  Столбец номер="+Str(Cell.Столбец));
         if     Cell.Текст = "Устанавливать" then

         ELSIF  Cell.Текст = "Поиск" then
           if Позиции[Index].ВзятьПоле     ("ЗначениеПоУмолчанию")="" then
           Иначе
              Позиции[Index].УстановитьПоле("ЗначениеПоУмолчанию","");
           end;
         ELSIF  Cell.Текст = "Расчёт" then
           if Позиции[Index].ВзятьПоле     ("ЗначениеПоУмолчанию")="" then
           Иначе
              Позиции[Index].УстановитьПоле("ЗначениеПоУмолчанию","");
           end;
         end;
      -- end;
     end;
  end;
  ---------------------------------------------------------
  proc BlankOnCreate                       (Context     : Variant);
    if ТипДокум="Справочники" then
    end;
  end;
  ---------------------------------------------------------
  proc BlankOnOpen                         (Create      : Logical);
    Перем I :Integer;
      -------
      ВидимостьПоляПодтаблица ;
      -------
      If секПриемник.RowsCount>1 then
          секПриемник.DeleteRow(1,секПриемник.RowsCount+1);
      end;
      if Отрезать(ИмяЛиста) = "" then
        CheckBox2.State=Ложь;
      ELSE
        CheckBox2.State=Истина;
      end;
      ВидимостьСтолбцаИмяЛиста ;
      для I = 1..ИмяЛистов.Количество цикл
         секцИсточник.Cell[4,2].List.Add(ИмяЛистов[I].GetField("Имя"));
      конец;
    Create = True ;
  end;
  ---------------------------------------------------------
  func BlankBeforeClose                    (ModalResult : Integer) :Logical;

    Result = True; -- Продолжить закрытие формы
  end;
  ---------------------------------------------------------
  func CellOnClick                         (Cell        : TemplateCell; Action :Template.ClickTypes) :Logical;
     Перем j : Целое ;

      Template.BeginModify;
      if Cell.Текст = "ю" then      -- Проставить "Галочки"
          for j=1.. Позиции.Count do
              Позиции[j].УстановитьПоле ("Загружаемое", Истина);
              Загружаемое[j] = Истина;
          end;
      ELSE                          -- Снять "Галочки"       Cell.Текст ="Ё"
          for j=1.. Позиции.Count do
              Позиции[j].УстановитьПоле ("Загружаемое", Ложь);
              Загружаемое[j] = Ложь;
          end;
      end;
      Template.EndModify;

    Result = True; -- Разрешаем стандартную обработку
  end;
  ---------------------------------------------------------
  proc ПолеКартотекаИмпортаПриВыходе       (Cell        : TemplateCell; Index :Integer);

     if СекДокум1.Cell[4,1].List.Count>0 then
        столбПодтаблица.Visible = Истина;
     ELSE
        столбПодтаблица.Visible = Ложь;
     end;

  end;
  ---------------------------------------------------------
  proc СкрываемТаблицу;
      Заголовок.Visible   = FALSE;
      секПозиции.Visible  = FALSE;
--      Замок               = FALSE;
      --Очистка временных переменных
      --Очистка временных переменных
  end;
  ---------------------------------------------------------
  proc ОткрываемТаблицу;
      Заголовок.Visible   = Истина;
      секПозиции.Visible  = Истина;
--      Замок               = Истина;
      --Очистка временных переменных
      --Очистка временных переменных
  end;
  ---------------------------------------------------------
  proc CheckBox2OnChange                   (Sender      : CheckBox);

       if  Sender.Caption = "Источник МногоЛистный (для xls-файлов)"  then
         CheckBox24.State = Sender.State;
         ВидимостьСтолбцаИмяЛиста ;
       elsif  Sender.Caption = "Документ заполнен" then     -- SELF
         Если Sender.State Тогда
           CheckBox2.State = Истина;
           ОткрываемТаблицу;
           УдалитьНарисованныеСекции;

         Иначе
           CheckBox2.State = Ложь;
           СкрываемТаблицу;
           РисуемКрасивыйШаблон ;
         Илсе;
       Fi;

  end;
  ---------------------------------------------------------
  proc ПроверитьФайл_Excel                 (Прайс       : Строка);
    Перем Excel :AutoObject;
    Перем I,Z :Integer;
       --"http://aristo.su/download/Price-Full.xlsx"
       if Прайс = "" then
       Иначе
         Excel = XLS_Create ;
         Excel = ОткрытьДоступКФайлуXLS(Прайс, Excel);
         if Excel = Nil then
         Иначе
           Z  = КоличествоЛистовВКниге (Excel);
           if Z > 0 then
              МассивXLS = ИменаЛистовНашейКниги  (НашаКнигаXLS);
              секцИсточник.Cell[4,2].List.Clear;
              DeleteSection (ИмяЛистов);
              секцИсточник.Cell[4,2].List.Add(" ");
              для I = 1.. Z цикл
                 секцИсточник.Cell[4,2].List.Add(МассивXLS[I]);
                 ИмяЛистов.Вставить(ИмяЛистов.Количество + 1);
                 ИмяЛистов[I].УстановитьПоле ("Имя",  МассивXLS[I]);
              конец;
              CheckBox24.State = Истина;
              ВидимостьСтолбцаИмяЛиста;
           end;
         end;
         ЗакрытьКнигу(Excel);
         ЗакрытьExcel(Excel);
       end;
  end;
  ---------------------------------------------------------
  func ПолеСсылкаНаПрайсПриВходе           (Cell        : TemplateCell; Index: Integer; Action :Template.EnterTypes) :Logical;
    If Match(Cell.Value, "http://*")2  или
     2  0Match(Cell.Value, "http2s0://*") Тогда
       Если API.ЕстьПодключение Тогда
       Иначе
          Трассировка("Нет подключения к Интернету. Проверка файла не возможна!");
          ВОЗВРАТ Ложь;
       end;
    end;
    if Action=0 then   --Ввод
        СсылкаНаПрайс = ВыбратьТабличныйФайл;
        if Match( ФайлРасширение, "*.xls?") then
             CheckBox24.Visible = Истина;
             ПроверитьФайл_Excel (СсылкаНаПрайс);
        elsif  ФайлРасширение = ".txt" then

        elsif  ФайлРасширение = ".ods" then
             CheckBox24.Visible = Истина;
             ПроверитьФайл_Excel (СсылкаНаПрайс);
        elsif  ФайлРасширение = ".dbf" then
             CheckBox24.Visible = Истина;
             ПроверитьФайл_Excel (СсылкаНаПрайс);
        elsif  ФайлРасширение = ".csv" then
             CheckBox24.Visible = Истина;
             ПроверитьФайл_Excel (СсылкаНаПрайс);
        else

        end;
    elsif   Action=1  then   --Вставка

    else   -- "2" - Очистка поля
       CheckBox24.Visible = Ложь;
       CheckBox24.State   = Ложь;
       ВидимостьСтолбцаИмяЛиста ;
       ИмяЛиста = "";
    end;
    Result = True; -- Разрешаем войти в поле
  end;
  ---------------------------------------------------------
  proc ПолеСсылкаНаПрайсПриВыходе          (Cell        : TemplateCell; Index: Integer);

    if Cell.Value="" then
       CheckBox24.Visible = Ложь;
       CheckBox24.State   = Ложь;
       ВидимостьСтолбцаИмяЛиста ;
       ИмяЛиста = "";
    else
      ФайлРасширение = СИС2.Файл.ВыделитьРасширениеФайла(Cell.Value);
      if Match( ФайлРасширение, "*.xls?") then
         CheckBox24.Visible = Истина;
         -- по условию
         ПроверитьФайл_Excel (Cell.Text);
         CheckBox24.Visible = Истина;
         CheckBox24.State   = Истина;
         ВидимостьСтолбцаИмяЛиста ;
      end;
    end;

  end;
  ---------------------------------------------------------
  func  ВзятьИндексМассива                 (Стр         : Строка): Integer;
    var   I     : Integer;
    var   Z     : Integer;
     I   = Поз("[", Стр) ;
     Z   = Поз("]", Стр) ;
     Result = Цел(ПодСтр(Стр,I+1, (Z-1)-I));
  end;
  ---------------------------------------------------------
  func ПолеРасчетноеВыражениеПриВходе      (Cell        : TemplateCell; Index: Integer; Action :Template.EnterTypes):Logical;
    var Стр   : Строка;
    var F     : BlankForm;
      Стр = Cell.Содержимое ;
      F = Импорт_ТД.Импорт_ТД.блРедакторВыражений.Создать;
      if Поз("[", Стр)=0 then
      Иначе
         Index = ВзятьИндексМассива(Стр);
      end;
      F.РасчетноеВыражение = Позиции[Index].GetField("РасчетноеВыражение");
      if F.Выполнить = 2 then
         Позиции[Index].УстановитьПоле("РасчетноеВыражение", F.РасчетноеВыражение);
         РасчетноеВыражение[Index] = F.РасчетноеВыражение;
      end;
      F.РасчетноеВыражение = "";
      F = Nil;
    Result = Ложь;
  end;
  ---------------------------------------------------------
Проц ДанныеИзXLS_В_Картотеку(WorkSheet:AutoObject);
 var Y, Z, YY, XX            : Целое      ;
 Перем ДиапазонПоиска        : Строка     ;
 Перем НашФайлСоотвФормату   : Логическое ;
 Перем Cells                 : AutoObject ;
 Перем Значение_Позиц        : Вариант    ;
 Перем Значение_Позиц1       : Вариант    ;
 Перем Rows                  : Целое      ;
 Перем Columns               : Целое      ;
 Перем НомерКолонкиСумма     : Целое      ;
 Перем НашеЧисло    : Логическое ;
 Перем НашеЧисло1   : Логическое ;

      Cells   = WorkSheet.UsedRange ; -- WorkSheet.UsedRange.Value2 как 0Вариант[2]   .Value
      Rows    = Cells.Rows.Count;      -- Строк   в Диапазоне
      Columns = Cells.Columns.Count;   -- Колонок в Диапазоне
         for YY = 1 .. Rows  do      -- строки Rows
            for XX = 1 .. Columns   do     -- столбы Column
              Значение_Позиц = Cells.Item[ YY , XX ].Value ;
              FData [YY ,XX ] = Значение_Позиц ;
              Задержка(ЗначениеЗадержки); -- Отдаем ресурсы другим приложениям
            oD;                          -- столбы Column
         oD;                             -- строки Rows
Цорп;
  ---------------------------------------------------------
  проц ЧтениеДанных  ;
    var    ExlЛист : AutoObject;  -- Excel,
      ---------------------------
      -- {Здесь нужно организовать считывание данных взависимости от Типа файла!!!
      ---------------------------
      try
         Excel = XLS_Create ;
         ОткрытьДоступКФайлуXLS( СсылкаНаПрайс, Excel);
         --------
           if  ИмяЛиста="" then
             ExlЛист = АктивироватьЛистНомер();
           Иначе
             ExlЛист = АктивироватьЛистНомер(НомерЛистаПоИмени(ИмяЛиста, Excel), Excel);    --Стр(ExlЛист)
           end;
           --1. Вариант... Долгий но более точный для Exl-файлов
           if СложноеФорматирование then
              ДанныеИзXLS_В_Картотеку(ExlЛист);
           --2. Вариант... Быстрый но подходит только для простых таблиц (без объединения полей, строк, колонок)
           Иначе
              FData = ExlЛист.UsedRange.Value2 как 0Вариант[2];   --Берём используемое пространство "Excel"
           end;
         --------
         ЗакрытьКнигу(Excel);
         ЗакрытьExcel(Excel);
      except
        Сообщение('Не удается запустить приложение MSO Excel. ' + ErrorText);
      end;
      ---------------------------
      -- }Здесь нужно организовать считывание данных взависимости от Типа файла!
      ---------------------------
  end;
  ---------------------------------------------------------
  --Тестовая Загрузка!!!
  var  ТестоваяЗагрузка : Логическое;
  проц Button1OnClick                      (Отправитель : Кнопка);
    var   Стр,W  : Целое;
    var   Отмена : Логическое;
    var   хПодтаблица  : Подтаблица;

      КоличЗагружПолей = 0;
      Отмена           = Ложь;
      ТестоваяЗагрузка = Истина;

      хПодтаблица      = Позиции.CreateSubtableView('Загружаемое=Истина');
      КоличЗагружПолей = хПодтаблица.count;
--      для Стр = 1.. Позиции.Количество цикл
--         Если Позиции[Стр].GetField("Загружаемое") Тогда
--           КоличЗагружПолей = КоличЗагружПолей + 1;
--         Илсе;
--      конец;

      Подсказка("1. Предварительное чтение данных из файла...");

      ЧтениеДанных;

      Подсказка("2. Вывод Тестовой Таблицы...");
      ---------------------------
      --Рисование Тестовой Таблицы
      Если ВыводТестовойТаблицы=0 Тогда   -- Если Отказ или Отмена или Закрыть
      --Рисование Тестовой Таблицы
        ---------------------------
      Иначе
        --Проверка загрузки в Турбо
        Отмена = ПроверитьПараметрыПередЗагрузкой;
        if Отмена then
        Иначе

          Подсказка("3. Загрузка данных из файла...");

          Загрузить;

        end;
      end;
      --Проверка загрузки в Турбо
      ---------------------------

      ---------------------------
  конец; --Тестовая Загрузка!!!
---------------------------------------------------------
  Проц РисуемКрасивыйШаблон ;
    var ОблШапка,    ОблТаблица, ОблИтогЛист, ОблСекВсего, ОблИнструменты : Область;
    var I        : Целое;
    var 2Масс0     : 2Вариант[2]0;
    var ТабДокум : Макет;

     Self.template.BeginModify;

         ТабДокум = ПолучитьМакет                   ("Импорт_ТД.Импорт_ТД.Макеты.ТаблицаСоотв");  -- Определяем бланк Макета.

         2-->Получение Данных:
         2--Вариант 1.
--         ТабДокум = ПолучитьМакет       ("D:\TB_FLY\Projects\Импорт_ТД\Бланки\Импорт_ТД\Макеты\ВременнаяТаблицаДанных.tpl");
--         если Структура.ЕстьДанные2      0(2"0Данные2"0) Тогда
--           2Масс0 = Структура.ВзятьДанные2 0(2"0Данные2"0); --Выбираем данные из ОПРЕДЕЛЕННОЙ секции.
--         конец;
--         2--Вариант 2.
--         ТабДокум = ПолучитьМакет       ("D:\TB_FLY\Projects\Импорт_ТД\Бланки\Импорт_ТД\Макеты\ВременнаяТаблицаДанных.tpl");
--         если Структура.ЕстьДанные2      0()         Тогда
--           2Масс = 0ТабДокум2.0data;                    --Копируем массив данных.
--         конец;
         2--<Получение Данных.

         ОблИнструменты = ТабДокум.ПолучитьОбласть  ("секИнструменты");
         ТабДокум.ВыводимОбласть  (ОблИнструменты);
--       2Self.template.EndModify; 0                         -- Рисуем область "Шапка". СЕЙЧАС - В любой момент рисуется всегда что-то ОДНО!
          --Заголовок Всех Страниц
--2       Self.template.BeginModify;
         ОблШапка        = ТабДокум.ПолучитьОбласть ("Шапка");  -- Определяем Секцию для вывода
         ТабДокум.ЗаголовокСтраниц();                           -- Определять Параметр Секции (после Самой Секции)!!!
         ТабДокум.ВыводимОбласть  (ОблШапка);
--2       Self.template.EndModify;
         -- Рисуем область "Шапка". СЕЙЧАС - В любой момент рисуется всегда что-то ОДНО!
          --Определяем Итог По Листу
--2       Self.template.BeginModify;
         ОблИтогЛист = ТабДокум.ПолучитьОбласть     ("ИтогЛист");
         ТабДокум.ИтогиСтраниц( ОблИтогЛист );     -- Аргументы могут быть пусто. "ОтКуда" и "Куда"
--2       Self.template.EndModify;
          --Определяем Итог По Листу
          --Рисуем Таблицу с данными
         ОблТаблица = ТабДокум.ПолучитьОбласть      ("Таблица");
         for I = 1 .. Позиции.Count do
            ОблТаблица.Параметры.Заполнить(Позиции[I]);                          -- В Цикле Рисования Должен быть первым (либо Структура, либо Структурированный Массив)
            ТабДокум.ВыводимОбласть (ОблТаблица, I);                             -- Рисуем  В Цикле Рисования Должен быть ПОСЛЕ "ЗаполнитьПараметр*"
            --Не работает подсчет итога! ОблТаблица.Параметры.Установить         ("ИтогоПоЛисту", ОблИтогЛист);
         end;
         ОблСекВсего = ТабДокум.ПолучитьОбласть     ("секВсего");
         ОблСекВсего.Параметры.Установить           ("Всего", 56565632.21);
         ТабДокум.ВыводимОбласть                    (ОблСекВсего);

     Self.template.EndModify;

  end;
  ------------------------------------------------
  func ВыводТестовойТаблицы : Целое;

    var ОблТаблица  : Область;
    var I,X,Y,Z     : Целое;
    var НомСтрДанных: Целое;
    var ТабДокум    : Макет;
    var TempRow     : TemplateRow;

         ТабДокум = ПолучитьМакет (); -- Определяем Макет для печати (Данные из этого бланка в стандартный "ТабличныйБланк").

         --Рисуем Таблицу с данными
         ОблТаблица = ТабДокум.ПолучитьОбласть();  -- Определяем Область для печати (Данные из этого бланка в стандартный "ТабличныйБланк").
         Y = ДлинаМассива(FData[1]);               -- Количество Колонок!!!
         Z = Если(ДлинаМассива(FData)>10, 10, ДлинаМассива(FData));

         for I = 1 .. Z do       -- По строкам Таблицы
           --Вариант
--           TempRow = ОблТаблица.ДобавитьСтроку;  --Добавляет в конец
--           ОблТаблица.РисуемКлеткуВСтроке(1,Y, TempRow);
           --Вариант
           --...
           --Вариант2
--           ОблТаблица.ВставитьСтроку(I); --Вставляет в Итерацию
--           ОблТаблица.РисуемКлеткуВСтроке(1,Y);
           --Вариант2
           --Вариант3 Поочередное Заполнение строкИ
--           for X  = 1 .. Y do                      -- По Колонкам Таблицы
--             ОблТаблица.Параметры.ЗаполнитьПараметр(X, FData[I,X]);
--           end;
           --Вариант3

           ОблТаблица.РисуемКлеткуВСтроке(1,Y);
           --Вариант4 Заполнение из Массива
           НомСтрДанных = I + (НомСтр-1);
           ОблТаблица.Параметры.ЗаполнитьПараметры(FData[НомСтрДанных]);
           --Вариант4
           ТабДокум.ВыводимОбласть (ОблТаблица, I);
         end;

         Результат = ТабДокум.Закрыть;  --Окончание рисования и открытие бланка... (Назвать по-другому)

  end;
  ------------------------------------------------
  ------------------------------------------------
  ------------------------------------------------
  ------------------------------------------------
  ------------------------------------------------
  --Функции Импорта
  --Функции Импорта
  --Функции Импорта

  var FieldsCount :integer = Позиции.Count ;
  var lClass: Class;

-------------------------------------------------------------------------------------------
  proc НазначитьКартотекуКлеткеНайденнойЗаписи;
    var lInterface: Class МашинаРеквизитов.Базовые.интЗапись;

      lClass = findclass(КартотекаИмпорта);
      if lClass<>nil then
        with Template.CellByField["НайдЗапись"] do
          lInterface = GetInterfaceByClass(lClass);
          if lInterface<>nil then
            CardfileName = str(lInterface.КартотекаПоУмолчанию);
            LookUpField  = if(ВКлассеЕстьПоле(lClass,"Код"),"Код","extid");
          end;
        end;
      end;
  end;
-------------------------------------------------------------------------------------------
  func ВыборПоля                           (Cell     : TemplateCell; Value  :Variant; var NewValue :Variant) :Logical;
    --var lClass: Class Record;
    var lField: string;

      lClass = findclass(КартотекаИмпорта);
      if lClass = nil then
        message("Не выбран класс записи");
      else
        lField = Value;
        if ChooseRecordField(lField, [lClass]) = cmOK then
          NewValue = lField;
        end;
      end;
      template.endedit(true);
  end;
-------------------------------------------------------------------------------------------
  func ИзСтроки                            (aVarType : Integer;      aValue :String ) :Variant;
      if (aVarType = varString) then
         Result = aValue;
            if Result = nil then
              Сообщение("Не верное определение типа данных!" + "[Строка<>"+ ВСтр(aValue)+"]");
            end;
      elsif (aVarType = varInt) then
            Result = Int(aValue);
            if Result = nil then
              Сообщение("Не верное определение типа данных!" + "[Целое<>"+ ВСтр(aValue)+"]");
            end;
      elsif (aVarType = varNumeric) then
            Result = Num(aValue);
            if Result = nil then
              Сообщение("Не верное определение типа данных!" + "[Число<>"+ ВСтр(aValue)+"]");
            end;
      elsif (aVarType = varLogical) then
            Result = (Up(aValue) = 'TRUE') or (Up(aValue) = 'ИСТИНА');
      elsif (aVarType = varDate) then
            Result = StringToDate(aValue);
            if Result = nil then
              Сообщение("Не верное определение типа данных!" + "[Дата<>"+ ВСтр(aValue)+"]");
            end;
      end;
  end;
-------------------------------------------------------------------------------------------
    var ТипКартПоля                         : Вариант;
-------------------------------------------------------------------------------------------
  func НайтиПоКоду                          (ПоКоду   : string) : record;
    var lRec                                : record;

      if ВКлассеЕстьПоле(ТипКартПоля, "Код") then
        lRec = FR(ТипКартПоля, "Код='"+ПоКоду+"'", "Код");
        if lRec=nil и СоздаватьСсылки then --не нашли ссылку, создаем новую
          lRec = (ТипКартПоля as class).Create;
          сис2.функциидокумента.RecordEdit(lRec);
          lRec.SetField ("Код", ПоКоду );
        end;
      end;
      Result = lRec;
  end;
-------------------------------------------------------------------------------------------
  func НайтиПоИмени                         (ПоИмени  : string) : record;
    var lRec                                : record;

      if ВКлассеЕстьПоле(ТипКартПоля, "Имя") then
        lRec = FR(ТипКартПоля, "Имя='"+ПоИмени+"'", "Имя");
        if lRec=nil и СоздаватьСсылки then --не нашли ссылку, создаем новую
          lRec = (ТипКартПоля as class).Create;
          сис2.функциидокумента.RecordEdit(lRec);
          lRec.SetField ("Имя", ПоИмени );
        end;
      end;
      Result = lRec;
  end;
-------------------------------------------------------------------------------------------
  func НоваяЗапись_                         (aRec     : record) : Record;
       Result = ОбновитьЗапись (aRec);
  end;
-------------------------------------------------------------------------------------------
  func ОбновитьЗапись                       (aRec     : record) : Record;
    var i,lPos,W,Q                          : integer;
    var ЗагружПоле, РежЗагрузки             : integer;
    var lStringValue,lField,lField1,lField2 : string;
    var lClass                              : class;
    var lRec                                : record;
    var StrValue, ПозицииИскатьПо           : string;
    var хПодтаблица                         : subtable;

    хПодтаблица    = Позиции.CreateSubtableView('Загружаемое=Истина');
    W              = хПодтаблица.count;

    if W=0 then
      Результат = nil;
    Иначе
      lClass = FindClass(Если(ПодтаблицаДанных="", КартотекаИмпорта, КартотекаИмпорта +"."+ ПодтаблицаДанных));
      for i = 1.. FieldsCount            do       --Цикл по полям картотеки!
          if Позиции.Items[i].Загружаемое then    -- Только "Загружаемое" поле
            ТипКартПоля = мТипПолей[i];
            --Q = хПодтаблица.NumberByIndex[i];   --Определяем Истинный номер позиции
            StrValue = "";
            lField = Позиции.Items[i].КартотечноеПоле;

            if lField="" then
            Иначе
              РежЗагрузки  = Позиции.Items[i].РежимЗагрузки;
              if РежЗагрузки=0 then                                                       -- "Поиск"
                  ЗагружПоле      = Позиции.Items[i].ЗагружаемоеПоле;
                  lStringValue    = Стр( FData[aRow, ЗагружПоле] );
                  -- Попытка получения "Ссылки" по "Код" или "Имя" из Импортируемых данных
                  if Позиции.Items[i].ТипДанныхКартПоля = 11 then -- Ссылка     Str(хПодтаблица.NumberByIndex[хПодтаблица.IndexByNumber[i]])
                    ПозицииИскатьПо = Позиции.Items[i].ИскатьПо;
                    --if ПозицииИскатьПо = "1" then
                    --  if ВКлассеЕстьПоле(мТипПолей[Q],"Код") then
                    --    StrValue = "Код=" + maskChar(lStringValue,"'");
                    --  end;
                    --end;
                    --if ПозицииИскатьПо = "2" then
                    --  if ВКлассеЕстьПоле(мТипПолей[Q],"Имя") then
                    --    StrValue = "Имя="+maskChar(lStringValue,"'");
                    --  end;
                    --end;
                    if ПозицииИскатьПо = "3" then
                      if ВКлассеЕстьПоле(ТипКартПоля,"Код") then
                         StrValue = "(Код="+ maskChar(lStringValue,"'")+ ")";
                      end;
                      if ВКлассеЕстьПоле(ТипКартПоля,"Имя") then
                        if StrValue="" then
                          StrValue  =                 "(Имя="+maskChar(lStringValue,"'") + ")";
                        Иначе
                          StrValue  = StrValue + " или (Имя="+maskChar(lStringValue,"'") + ")";
                        end;
                      end;
                    end;
                  end; --if Позиции[i].GetField("ТипДанныхКартПоля")=11 then -- Ссылка

              elsif РежЗагрузки=1 и Позиции.Items[i].РасчетноеВыражение > "" then     -- "РАСЧЁТ"
                 if ТипКартПоля=1 then  -- Для "строки" и "Простое поле"
                     --Пока Вычисляется строка: ' "["+ FData[aRow, 1] +"/"+ FData[aRow, 2]+"..."+ FData[aRow, 3]" '
                     lStringValue = Вычислить(Позиции.Items[i].РасчетноеВыражение);
                 end;
                 --Пока не реализовано для других Типов!!!!
              elsif РежЗагрузки=2 then                                                    -- "Установить" по-умолчанию
                  lStringValue = Стр(Позиции.Items[i].ЗначениеПоУмолчанию );
                  -- Попытка получения
                  if Позиции.Items[i].ТипДанныхКартПоля = 11 then -- Ссылка
                    ПозицииИскатьПо = Позиции.Items[i].ИскатьПо;
                    -- Позиции[i].GetField("ТипДанныхКартПоля")<>varString,lStringValue,maskChar(lStringValue,"'")
                    --if ПозицииИскатьПо="1" then
                    --  if ВКлассеЕстьПоле(мТипПолей[Q],"Код") then
                    --    StrValue = "Код=" + maskChar(lStringValue,"'");
                    --  end;
                    --end;
                    --if ПозицииИскатьПо="2" then
                    --  if ВКлассеЕстьПоле(мТипПолей[Q],"Имя") then
                    --    StrValue = "Имя="+maskChar(lStringValue,"'");
                    --  end;
                    --end;
                    if ПозицииИскатьПо="3" then
                      if ВКлассеЕстьПоле(ТипКартПоля,"Код") then
                         StrValue = "(Код="+ maskChar(lStringValue,"'")+ ")";
                      end;
                      if ВКлассеЕстьПоле(ТипКартПоля,"Имя") then
                        if StrValue="" then
                          StrValue  =                 "(Имя="+maskChar(lStringValue,"'") + ")";
                        Иначе
                          StrValue  = StrValue + " или (Имя="+maskChar(lStringValue,"'") + ")";
                        end;
                      end;
                    end;
                  end; --if Позиции[i].GetField("ТипДанныхКартПоля")=11 then -- Ссылка
              end;

              if not ТипКартПоля is Class then --это простое поле
                aRec.SetField(lField, ИзСтроки(ТипКартПоля, lStringValue));
              else --это запись
                --ищем существующую ссылку
                if lStringValue in ["","nil"] then  --Варианты "Нулевых" значений
                  lRec = nil;
                else
                    --lRec = FR(мТипПолей[Q], StrValue);
                    --if lRec=nil и СоздаватьСсылки then --не нашли ссылку, создаем новую
                      --lRec = (мТипПолей[Q] as class).Create;
                      --сис2.функциидокумента.RecordEdit(lRec);
                      if ПозицииИскатьПо="2" then
                        lRec = НайтиПоИмени(lStringValue);
                        --lRec.SetField ("Имя",  lStringValue );
                        if ВКлассеЕстьПоле(ТипКартПоля, "Код") and lRec.Код="" then      --  if ВКлассеЕстьПоле(lClass,"Код") and lRec.Код="" then
                          lRec.Код = lRec.Имя;
                        end;
                      Иначе
                        if ПозицииИскатьПо="3" then
                          lRec = FR(ТипКартПоля, StrValue);
                          if lRec=nil и СоздаватьСсылки then
                            lRec = (ТипКартПоля as class).Create;
                            сис2.функциидокумента.RecordEdit(lRec);
                            lRec.SetField ("Имя", lStringValue );
                            lRec.SetField ("Код", lStringValue );
                          end;
                        Иначе
                          lRec = НайтиПоКоду(lStringValue);
  --                         lRec.SetField ("Код", lStringValue );
                          if ВКлассеЕстьПоле(ТипКартПоля, "Имя") and lRec.Имя="" then
                            lRec.Имя = lRec.Код;
                          end;
                        end;
                      end;

                      попытка
                         сис2.функциидокумента.RecordPost(lRec);
                      Исключение
                         lRec = nil ;
                         Трассировка("Записать -'"+lStringValue+"' в "+Стр(ТипКартПоля)+" - не удалось!");
                      конец;

  --                  end;
                end;
                if lRec = nil then
                  --
                else
                  aRec.SetField(lField, lRec);
                end;
              end;
            end;-- lField<>""
          end; -- Если Загружаемое
      end;--for i
      if ВКлассеЕстьПоле(lClass,"Код") and aRec.Код="" then
        aRec.Код = aRec.extid;
      end;
      if ВКлассеЕстьПоле(lClass,"Имя") and aRec.Имя="" then
        aRec.Имя = aRec.Код;
      end;
      if ТестоваяЗагрузка then
        if (aRec.State = Record.Edited) or (aRec.State = Record.Created) then
           Трассировка("Запись -'"+Стр(aRec)+"' в "+Стр(ТипКартПоля)+" - тест загрузки прошел удачно!");
           aRec.Cancel;
        end;
      end;
      Result = aRec;
    end;-- W=0
  end;
-------------------------------------------------------------------------------------------
  var мТипПолей         : variant[]; -- тип полей, чтобы не вычислять на каждой итерации
  var мТипРазыменований : variant[]; -- если тип поля запись - то тип разыменования
-------------------------------------------------------------------------------------------
  func FindRecord synonym FR(Name:class record; filter:string; Loading_Fields:string=""; AllowRightChecking:logical=true):record;
    var q:query;

    result = Nil;

    if filter = "" then
    Иначе
      q=query.create([Name]);
      q.loadingFieldsMode              = сис2.константы.mdNone;
      q.openHint[q.LargeResult]        = true;
      q.openHint[q.Packeting]          = true;
      q.OpenHint[q.IgnoreRecordFilter] = not AllowRightChecking;
      q.PacketSize                     = 1;
      q.filter                         = filter;
      if q.RecordsExists then         --Сильно ускоряет Запрос!!!!!
      --q.order                          = orderFields;
        if Loading_Fields = "" then
        Иначе
          q.LoadingFields                = Loading_Fields;
        end;
        q.select;
        q.Last; -- переходим к последнему документу

        if q.BOF и q.EOF then      --Пустой Запрос
          result = Nil;
        Иначе
          result = q.current;
        end;
      Иначе
        Return;
      end;
    end;
  end;
-------------------------------------------------------------------------------------------
  proc ОпределитьТипПолей;
    var lClass : Class Объект;
    var i,lPos : integer;
    var lField : string;

    lClass            = FindClass(Если(ПодтаблицаДанных="", КартотекаИмпорта, КартотекаИмпорта +"."+ ПодтаблицаДанных));
    мТипПолей         = nil;
    мТипРазыменований = nil;

    for i = 1..FieldsCount do
      lField = Позиции[i].GetField("КартотечноеПоле");    -- КартотечноеПоле   "НаимЗначение"
      lPos   = pos(".",lField);
      if lPos=0 then -- это простое поле
        мТипПолей[i]         = ПолучитьТипСвойстваКлассаПоИмени ( lClass, lField                  );  --    Позиции[i].GetField("ТипДанныхКартПоля")
      else           -- это запись
        мТипПолей[i]         = ПолучитьТипСвойстваКлассаПоИмени ( lClass, substr(lField,1,lPos-1) );
        мТипРазыменований[i] = ПолучитьТипСвойстваКлассаПоИмени ( lClass, lField                  );
      end;
    end;
  end;
-------------------------------------------------------------------------------------------
--InObject Private

--InClass Public
--class inherited Первичка.БазовыйБланк "Универсальный Загрузчик";
--
--import сис2 classes исключения,строковыефункции,функцииртти,функциидокумента,функции;
--import tf_базовый classes функции,массивы;
--import МашинаРеквизитов classes Библио;
--
--inobject private
----
----Const FieldsCount:integer=20;
----
--var КартотекаИмпорта : строка;
--stored var КартотекаИмпорта:строка;
--stored var путькфайлу:строка;
--stored var ОбновлятьНайденные:logical;
----var ОбновлятьНайденные : logical;
----stored var НомСтр: integer;
----var СекПозиции :TemplateSection;
--stored var СоздаватьСсылки:logical;
-------------------------------------------------------------------------------------------
  func ПроверитьПараметрыПередЗагрузкой : logical ;
    var лЕстьПолеПоиска:logical;
    var i, ЗагружПоле, РежЗагрузки: integer;
    --var lClass: Class;
    var lField: string;
    var lSearchField: logical;
      result = true;
      --lClass = findclass(КартотекаИмпорта);
      if lClass=nil then
        message("Не задан класс записи");
        return;
      end;

      for i=1..FieldsCount do
        lSearchField = Позиции[i].GetField("Загружаемое");      -- Позиции.Items[i]
        ЗагружПоле   = Позиции[i].GetField("ЗагружаемоеПоле");
        РежЗагрузки  = Позиции[i].GetField("РежимЗагрузки");    -- Поиск, Расчёт, Устанавливать

        if lSearchField=Истина и ЗагружПоле=0 и РежЗагрузки=1 then
          message("Задан флаг поиска, но не указан номер колонки поля загрузки!");
          return;
        elsif lSearchField=Истина и РежЗагрузки=1 и Позиции[i].GetField("РасчетноеВыражение")="" then   -- Расчёт
          message("Задан флаг поиска, но для режима 'РАСЧЁТ' - не указан код расчета поля!");
          return;
--        elsif WordsCount(lField,".")>1 then
--          message("Нельзя использовать двойное разыменование");
--          return;
--        elsif ПолучитьТипСвойстваКлассаПоИмени(lClass,lField) is Class then
--          message("Нельзя использовать поле-запись");
--          return;
        end;
        лЕстьПолеПоиска = лЕстьПолеПоиска or lSearchField;
      end;

      if not лЕстьПолеПоиска then
        message("Не задано ни одного поля поиска");
        return;
      end;

    result = Ложь;
  end;
-------------------------------------------------------------------------------------------
var aRow:integer ;
  func ПолучитьФильтрЗаписи : string;
    var i,g,W         : integer;
    var ЗагружПоле    : integer;
    var СтрокаФильтра : string;
    var lValue        : string;
    var lField        : string;
    var ЭтоПолеПоиска : logical;
    var лУсловияПоиска: string[];
    var ТипДанн       : integer;
    var хПодтаблица   : subtable;
    var РежЗагрузки   : integer;

    лУсловияПоиска = nil;

    хПодтаблица    = Позиции.CreateSubtableView('ПолеПоиска=Истина');
    W              = хПодтаблица.count;
    if W=0 then
      Результат = "";
    Иначе
      for g=1.. W do
  --    for g=1..FieldsCount do
  --      ЭтоПолеПоиска = Позиции[g].GetField("ПолеПоиска");
  --      if ЭтоПолеПоиска then
            lField     = хПодтаблица.ItemsByNumber[g].КартотечноеПоле;
            ЗагружПоле = хПодтаблица.ItemsByNumber[g].ЗагружаемоеПоле;
            --Возникнут проблемы с "Датой" и "Числом" а именно "Разделители"   хПодтаблица.ItemsByNumber[g].ЗагружаемоеПоле
            lValue     = str(FData[aRow, ЗагружПоле]);
            ТипДанн    = хПодтаблица.ItemsByNumber[g].ТипДанныхКартПоля;
            РежЗагрузки= хПодтаблица.ItemsByNumber[g].РежимЗагрузки;
            if РежЗагрузки=1 и хПодтаблица.ItemsByNumber[g].РасчетноеВыражение > "" then     -- "РАСЧЁТ"
              lValue = Вычислить(хПодтаблица.ItemsByNumber[g].РасчетноеВыражение);
            end;
            if ТипДанн=1 or ТипДанн=11 then
              lValue = MaskChar(lValue,"'");
            end;
            лУсловияПоиска[lengthofarray(лУсловияПоиска)+1] = lField+"="+ lValue;
  --      end;
      end;
      СтрокаФильтра = сис2.строковыефункции.СложитьСтрокиФильтраПоИ(лУсловияПоиска);
      Результат = СтрокаФильтра;
    end;
  end;
-------------------------------------------------------------------------------------------
  func ЕстьФильтр :logical;
    var i,g,W         : integer;
    var ЗагружПоле    : integer;
    var СтрокаФильтра : string;
    var lValue        : string;
    var lField        : string;
    var ЭтоПолеПоиска : logical;
    var хПодтаблица   : subtable;

    хПодтаблица = Позиции.CreateSubtableView('ПолеПоиска=Истина');
    W           = хПодтаблица.count;
    if W=0 then
      Результат = Ложь;
    Иначе
      Результат = true;
--    for g=1..FieldsCount do
--      for g=1.. W do
--        --if Позиции[g].GetField("ПолеПоиска") then
--          --lField        = хПодтаблица.ItemsByNumber[i].КартотечноеПоле;
--          ЭтоПолеПоиска = хПодтаблица.ItemsByNumber[i].ПолеПоиска;
--          if ЭтоПолеПоиска then
--              return Истина;
--          end;
--        --end;
--      end;
    end;
    return Результат;   --Убрать
  end;
-------------------------------------------------------------------------------------------
  func ПолныеДанные :logical;
    var i,Z,Q,W        : integer;
    var лУсловия       : integer[];

    Q = 0;
    W = 0;
    Результат = Истина;

    if Trim(ОбязятельныеПоля)="" then
    Иначе
      лУсловия = Вычислить("["+ОбязятельныеПоля+"]");
      Q        = LengthOfArray (лУсловия);
    end;
    if Q=0 then
    Иначе
      for i = 1.. Q do
        if (str(FData[aRow, лУсловия[i]] ) in ["","nil"]) then     --FData[aRow]
          trace("строка "+str(aRow)+" пропущена...");
          Результат = Ложь;
          Прервать;
        end;
      end;
    end;
    return Результат;
  end;
-------------------------------------------------------------------------------------------
  func ЗначениеХотяБыОдногоЗагружаемогоПоляЗадано:logical;
    var i,Z,Q,W        : integer;
    var ЗагружПоле     : integer;
    var лУсловия       : integer[];
    var хПодтаблица    : subtable;

    Q = 0;
    W = 0;
    Результат = Ложь;

    хПодтаблица = Позиции.CreateSubtableView('Загружаемое=Истина');
    W           = хПодтаблица.count;
    for i = 1.. W do
      --хПодтаблица2 = хПодтаблица.ItemsByNumber[i];
      --if хПодтаблица.ItemsByNumber[i].РежимЗагрузки = 0 then  -- "ПолеПоиска"
        ЗагружПоле = хПодтаблица.ItemsByNumber[i].ЗагружаемоеПоле;
        if (str(FData[aRow,ЗагружПоле]) in ["","nil"]) then   --FData[11,1]
        Иначе
          Результат = true;  --  Значение Хотя Бы Одного Поля "Загружаемое" Задано!
          Прервать;
        end;
      --end;
    end;

    return Результат;
  end;
-------------------------------------------------------------------------------------------
  var mTempRecord: Record;    --найденная/созданная запись
-------------------------------------------------------------------------------------------
  proc Загрузить;
    var ВКлассеЕстьКод  : Логическое;
    var ВКлассеЕстьИмя  : Логическое;
    var ЭтоПолеПоиска   : Логическое;
    var СобиратьФильтр  : Логическое;
    var Искать          : string;
--    var ТипДанн         : integer;
    var ЗагружПоле      : integer;
    var i, g            : integer;
    var лУсловияПоиска  : string[];
    var lClass          : Class Объект;   -- Объект Record
--    var lValue          : string;
--    var lField          : string;
    var lStartDate      : date;
    var СтрокаПоиска    : string;

--    var mTempR1         : Record;
--    var mTempR2         : Record;
--    var mTempR3         : Record;

--    var Sub             : Subtable;


    if ПроверитьПараметрыПередЗагрузкой then
      return;
    end;

    lStartDate = Now;
    lClass     = FindClass(Если(ПодтаблицаДанных="", КартотекаИмпорта, КартотекаИмпорта +"."+ ПодтаблицаДанных));         -- FindClass(КартотекаИмпорта +"."+ ПодтаблицаДанных )   --КартотекаИмпорта
    aRow       = НомСтр;
    i          = 1;

    ОпределитьТипПолей;

    ВКлассеЕстьКод  = Ложь;
    ВКлассеЕстьИмя  = Ложь;
    if ВКлассеЕстьПоле(lClass,"Код") then
       ВКлассеЕстьКод = Истина;
    end;
    if ВКлассеЕстьПоле(lClass,"Имя") then
       ВКлассеЕстьИмя = Истина;
    end;

    if ЕстьФильтр then
        СобиратьФильтр = Истина;
    end;

    while aRow < ДлинаМассива(FData)+НомСтр+1 do
  --  while ЗначениеХотяБыОдногоЗагружаемогоПоляЗадано do
      hint("Загрузка строки " + str(i));
      if ПолныеДанные then

        try
          --Обнуляем переменные каждый Цикл!!!
          лУсловияПоиска = nil;  СтрокаПоиска = ""; mTempRecord=nil;
          if ссылкаДокумент = nil then  --Записываем В Корень Записи!!!
              --формируем строку поиска
              if СобиратьФильтр then
                 СтрокаПоиска = ПолучитьФильтрЗаписи ;
                 --ищем
                 mTempRecord = FR(lClass, СтрокаПоиска);            --Поиск Записи по фильтру!!!
              end;
              --создаем/обновляем
              if mTempRecord=nil then                               -- Создаем новые!!!
                mTempRecord = lClass.Create;

                сис2.функциидокумента.RecordEdit(mTempRecord);

                 НоваяЗапись_ (mTempRecord);

                сис2.функциидокумента.RecordPost(mTempRecord);
              Иначе                                                   -- Существует запись!!!
                if ОбновлятьНайденные then                            -- А обновлять ли старые Записи?
                  сис2.функциидокумента.RecordEdit(mTempRecord);
                  if mTempRecord.CreateDate < lStartDate then         -- Да. Старая Запись?
                    ОбновитьЗапись(mTempRecord);                -- Да. Обновляем все поля записи.
                  end;
                  сис2.функциидокумента.RecordPost(mTempRecord);
                end;
              end;
          Иначе       --Записываем В Подтаблицу Записи!!!
             --ищем
--                mTempRecord = lClass.Create;
--                Sub = Вычислить( ПодСтр(Стр(ссылкаДокумент),2,Длина(Стр(ссылкаДокумент))-2 ) +"."+ ПодтаблицаДанных) ;
--                Sub = ссылкаДокумент.Позиции;
--                i = Sub.Добавить;
--
----                func OpenRecordFromString (aString:string):record;
----                  var lPos:integer;
----
----                  if not (aString in ["nil",""]) then
----                    lPos = Pos(":",aString);
----                    if lPos>0 then
----                      result=findclass(substr(aString,2,lPos-2)).open(aString);
----                    end;
----                  end;
----                end;
--
--                 FindClass()                 ссылкаДокумент.Позиции.Количество
--
--                lClass.
--                сис2.функциидокумента.RecordEdit(mTempRecord);
--
--                 НоваяЗапись_ (mTempRecord);
--
--                сис2.функциидокумента.RecordPost(mTempRecord);

          end;
        исключение
          trace("строка "+str(aRow)+" не загружена");
        конец;
      end; --if
      i    = i   +1;
      aRow = aRow+1;
    end; --do i
  end;
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
end